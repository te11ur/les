Комментарии на основе того, как я понял задание. И по коду немного

Kochetov:
    add(newNode) - ok. (ошибка если newNode не объект)
    remove(id) - getNode ищет совпадение по id у себя, у соседей (только next, prev не рассматривает),
    на мой взгляд сложная и плохочитаемая логика, вместо повротения currentNode.children и currentNode.next
    лучше сделать деструторизацию children и next
    each(cb) - если есть сосед, то проходит только по ним (только next), или только по детям (один уровень)
    Оценка: 3 - пересдача 

Lebadina:
    add(...args) - ok. добавляет в конец списка (по заданию как я понял, нужно было добалять в children к parent,
    предыдущий из children становится next)
    getChildren() - ok
    each() - ok
    traverse() - ok
    swap() - не доделано
    findChild(id) - может найти себя или соседей (только next), дальше ок
    remove(id) - у меня почему-то не работает
    getHtml(params = {}) и renderElem(params = {}) - не по теме, точно Node не должен заниматься рендером
    Оценка: 6 - на доработку

Lynko:
    хитрая схема с обновлением чайлдов, но суть была минимизировать работу с массивами
    this.children[`${newChild.id}`] ??
    по заданию, children должен ссылаться на последний добавленный чайлд
    Оценка: 4 - на доработку

Parfionov: 
    length - общая на все уровни? я не понял ее сути
    add(...childrens) - 
        child.next = null; - он и так null при создании
        по заданию, children должен быть последним добаленным node
    traverse(cb) - только один уровень чайлдов
    remove() - по идее, удаляет себя, но не сделает это, если нету соседей ( if (!this.prev && !this.next))
    removeChild 
    getNext и getPrev - лишние
    Оценка: 4 - на доработку

Resgul:
    что-то не по теме
    Оценка: 1 - пересдача

